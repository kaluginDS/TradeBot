// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип операции со списком подписок.
public enum SubscriptionAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Подписаться.
  case subscribe // = 1

  ///Отписаться.
  case unsubscribe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .subscribe
    case 2: self = .unsubscribe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .subscribe: return 1
    case .unsubscribe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionAction] = [
    .unspecified,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечи.
public enum SubscriptionInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал свечи не определён.
  case unspecified // = 0

  ///Минутные свечи.
  case oneMinute // = 1

  ///Пятиминутные свечи.
  case fiveMinutes // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMinute
    case 2: self = .fiveMinutes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMinute: return 1
    case .fiveMinutes: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionInterval] = [
    .unspecified,
    .oneMinute,
    .fiveMinutes,
  ]
}

#endif  // swift(>=4.2)

///Результат подписки.
public enum SubscriptionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Статус подписки не определён.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Инструмент не найден.
  case instrumentNotFound // = 2

  ///Некорректный статус подписки, список возможных значений: [SubscriptionAction](https://tinkoff.github.io/investAPI/marketdata#subscriptionaction)
  case subscriptionActionIsInvalid // = 3

  ///Некорректная глубина стакана, доступные значения: 10, 20, 30, 40, 50.
  case depthIsInvalid // = 4

  ///Некорректный интервал свечей, список возможных значений: [SubscriptionInterval](https://tinkoff.github.io/investAPI/marketdata#subscriptioninterval)
  case intervalIsInvalid // = 5

  ///Превышен лимит подписок в рамках стрима, подробнее: [Лимитная политика](https://tinkoff.github.io/investAPI/limits/)
  case limitIsExceeded // = 6

  ///Внутренняя ошибка сервиса.
  case internalError // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .instrumentNotFound
    case 3: self = .subscriptionActionIsInvalid
    case 4: self = .depthIsInvalid
    case 5: self = .intervalIsInvalid
    case 6: self = .limitIsExceeded
    case 7: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .instrumentNotFound: return 2
    case .subscriptionActionIsInvalid: return 3
    case .depthIsInvalid: return 4
    case .intervalIsInvalid: return 5
    case .limitIsExceeded: return 6
    case .internalError: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SubscriptionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubscriptionStatus] = [
    .unspecified,
    .success,
    .instrumentNotFound,
    .subscriptionActionIsInvalid,
    .depthIsInvalid,
    .intervalIsInvalid,
    .limitIsExceeded,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

///Направление сделки.
public enum TradeDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Направление сделки не определено.
  case unspecified // = 0

  ///Покупка.
  case buy // = 1

  ///Продажа.
  case sell // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TradeDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TradeDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

///Интервал свечей.
public enum CandleInterval: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Интервал не определён.
  case unspecified // = 0

  ///1 минута.
  case candleInterval1Min // = 1

  ///5 минут.
  case candleInterval5Min // = 2

  ///15 минут.
  case candleInterval15Min // = 3

  ///1 час.
  case hour // = 4

  ///1 день.
  case day // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .candleInterval1Min
    case 2: self = .candleInterval5Min
    case 3: self = .candleInterval15Min
    case 4: self = .hour
    case 5: self = .day
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .candleInterval1Min: return 1
    case .candleInterval5Min: return 2
    case .candleInterval15Min: return 3
    case .hour: return 4
    case .day: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CandleInterval: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CandleInterval] = [
    .unspecified,
    .candleInterval1Min,
    .candleInterval5Min,
    .candleInterval15Min,
    .hour,
    .day,
  ]
}

#endif  // swift(>=4.2)

///Запрос подписки или отписки на определённые биржевые данные.
public struct MarketDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataRequest.OneOf_Payload? = nil

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: SubscribeCandlesRequest {
    get {
      if case .subscribeCandlesRequest(let v)? = payload {return v}
      return SubscribeCandlesRequest()
    }
    set {payload = .subscribeCandlesRequest(newValue)}
  }

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: SubscribeOrderBookRequest {
    get {
      if case .subscribeOrderBookRequest(let v)? = payload {return v}
      return SubscribeOrderBookRequest()
    }
    set {payload = .subscribeOrderBookRequest(newValue)}
  }

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: SubscribeTradesRequest {
    get {
      if case .subscribeTradesRequest(let v)? = payload {return v}
      return SubscribeTradesRequest()
    }
    set {payload = .subscribeTradesRequest(newValue)}
  }

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: SubscribeInfoRequest {
    get {
      if case .subscribeInfoRequest(let v)? = payload {return v}
      return SubscribeInfoRequest()
    }
    set {payload = .subscribeInfoRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Запрос подписки на свечи.
    case subscribeCandlesRequest(SubscribeCandlesRequest)
    ///Запрос подписки на стаканы.
    case subscribeOrderBookRequest(SubscribeOrderBookRequest)
    ///Запрос подписки на ленту обезличенных сделок.
    case subscribeTradesRequest(SubscribeTradesRequest)
    ///Запрос подписки на торговые статусы инструментов.
    case subscribeInfoRequest(SubscribeInfoRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: MarketDataRequest.OneOf_Payload, rhs: MarketDataRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesRequest, .subscribeCandlesRequest): return {
        guard case .subscribeCandlesRequest(let l) = lhs, case .subscribeCandlesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookRequest, .subscribeOrderBookRequest): return {
        guard case .subscribeOrderBookRequest(let l) = lhs, case .subscribeOrderBookRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesRequest, .subscribeTradesRequest): return {
        guard case .subscribeTradesRequest(let l) = lhs, case .subscribeTradesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoRequest, .subscribeInfoRequest): return {
        guard case .subscribeInfoRequest(let l) = lhs, case .subscribeInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///Пакет биржевой информации по подписке.
public struct MarketDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataResponse.OneOf_Payload? = nil

  ///Результат подписки на свечи.
  public var subscribeCandlesResponse: SubscribeCandlesResponse {
    get {
      if case .subscribeCandlesResponse(let v)? = payload {return v}
      return SubscribeCandlesResponse()
    }
    set {payload = .subscribeCandlesResponse(newValue)}
  }

  ///Результат подписки на стаканы.
  public var subscribeOrderBookResponse: SubscribeOrderBookResponse {
    get {
      if case .subscribeOrderBookResponse(let v)? = payload {return v}
      return SubscribeOrderBookResponse()
    }
    set {payload = .subscribeOrderBookResponse(newValue)}
  }

  ///Результат подписки на поток обезличенных сделок.
  public var subscribeTradesResponse: SubscribeTradesResponse {
    get {
      if case .subscribeTradesResponse(let v)? = payload {return v}
      return SubscribeTradesResponse()
    }
    set {payload = .subscribeTradesResponse(newValue)}
  }

  ///Результат подписки на торговые статусы инструментов.
  public var subscribeInfoResponse: SubscribeInfoResponse {
    get {
      if case .subscribeInfoResponse(let v)? = payload {return v}
      return SubscribeInfoResponse()
    }
    set {payload = .subscribeInfoResponse(newValue)}
  }

  ///Свеча.
  public var candle: Candle {
    get {
      if case .candle(let v)? = payload {return v}
      return Candle()
    }
    set {payload = .candle(newValue)}
  }

  ///Сделки.
  public var trade: Trade {
    get {
      if case .trade(let v)? = payload {return v}
      return Trade()
    }
    set {payload = .trade(newValue)}
  }

  ///Стакан.
  public var orderbook: OrderBook {
    get {
      if case .orderbook(let v)? = payload {return v}
      return OrderBook()
    }
    set {payload = .orderbook(newValue)}
  }

  ///Торговый статус.
  public var tradingStatus: TradingStatus {
    get {
      if case .tradingStatus(let v)? = payload {return v}
      return TradingStatus()
    }
    set {payload = .tradingStatus(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    ///Результат подписки на свечи.
    case subscribeCandlesResponse(SubscribeCandlesResponse)
    ///Результат подписки на стаканы.
    case subscribeOrderBookResponse(SubscribeOrderBookResponse)
    ///Результат подписки на поток обезличенных сделок.
    case subscribeTradesResponse(SubscribeTradesResponse)
    ///Результат подписки на торговые статусы инструментов.
    case subscribeInfoResponse(SubscribeInfoResponse)
    ///Свеча.
    case candle(Candle)
    ///Сделки.
    case trade(Trade)
    ///Стакан.
    case orderbook(OrderBook)
    ///Торговый статус.
    case tradingStatus(TradingStatus)
    ///Проверка активности стрима.
    case ping(Ping)

  #if !swift(>=4.1)
    public static func ==(lhs: MarketDataResponse.OneOf_Payload, rhs: MarketDataResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeCandlesResponse, .subscribeCandlesResponse): return {
        guard case .subscribeCandlesResponse(let l) = lhs, case .subscribeCandlesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeOrderBookResponse, .subscribeOrderBookResponse): return {
        guard case .subscribeOrderBookResponse(let l) = lhs, case .subscribeOrderBookResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeTradesResponse, .subscribeTradesResponse): return {
        guard case .subscribeTradesResponse(let l) = lhs, case .subscribeTradesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeInfoResponse, .subscribeInfoResponse): return {
        guard case .subscribeInfoResponse(let l) = lhs, case .subscribeInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.candle, .candle): return {
        guard case .candle(let l) = lhs, case .candle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trade, .trade): return {
        guard case .trade(let l) = lhs, case .trade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orderbook, .orderbook): return {
        guard case .orderbook(let l) = lhs, case .orderbook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tradingStatus, .tradingStatus): return {
        guard case .tradingStatus(let l) = lhs, case .tradingStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// subscribeCandles | Изменения статуса подписки на свечи.
public struct SubscribeCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на свечи.
  public var instruments: [CandleInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос изменения статус подписки на свечи.
public struct CandleInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: SubscriptionInterval = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статус подписки на свечи.
public struct SubscribeCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id)
  public var trackingID: String = String()

  ///Массив статусов подписки на свечи.
  public var candlesSubscriptions: [CandleSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на свечи.
public struct CandleSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: SubscriptionInterval = .unspecified

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос на изменение статуса подписки на стаканы.
public struct SubscribeOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на стаканы.
  public var instruments: [OrderBookInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на стаканы.
public struct OrderBookInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на стаканы.
public struct SubscribeOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id)
  public var trackingID: String = String()

  ///Массив статусов подписки на стаканы.
  public var orderBookSubscriptions: [OrderBookSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct OrderBookSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на поток обезличенных сделок.
  public var instruments: [TradeInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на поток обезличенных сделок.
public struct TradeInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id)
  public var trackingID: String = String()

  ///Массив статусов подписки на поток сделок.
  public var tradeSubscriptions: [TradeSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct TradeSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на торговый статус инструмента.
public struct SubscribeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на торговый статус.
  public var instruments: [InfoInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на торговый статус.
public struct InfoInstrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на торговый статус.
public struct SubscribeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id)
  public var trackingID: String = String()

  ///Массив статусов подписки на торговый статус.
  public var infoSubscriptions: [InfoSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct InfoSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Пакет свечей в рамках стрима.
public struct Candle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечи.
  public var interval: SubscriptionInterval = .unspecified

  ///Цена открытия за 1 лот.
  public var `open`: Quotation {
    get {return _open ?? Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 лот.
  public var high: Quotation {
    get {return _high ?? Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 лот.
  public var low: Quotation {
    get {return _low ?? Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 лот.
  public var close: Quotation {
    get {return _close ?? Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём сделок в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Quotation? = nil
  fileprivate var _high: Quotation? = nil
  fileprivate var _low: Quotation? = nil
  fileprivate var _close: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет стаканов в рамках стрима.
public struct OrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Флаг консистентности стакана. **false** значит не все заявки попали в стакан по причинам сетевых задержек или нарушения порядка доставки.
  public var isConsistent: Bool = false

  ///Массив предложений.
  public var bids: [Order] = []

  ///Массив спроса.
  public var asks: [Order] = []

  ///Время стакана в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Массив предложений/спроса.
public struct Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена за 1 лот.
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество в лотах.
  public var quantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
}

///Информация о сделке.
public struct Trade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Направление сделки.
  public var direction: TradeDirection = .unspecified

  ///Цена за 1 лот.
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество лотов.
  public var quantity: Int64 = 0

  ///Время сделки в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет изменения торгового статуса.
public struct TradingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  ///Время изменения торгового статуса в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос исторических свечей.
public struct GetCandlesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал запрошенных свечей.
  public var interval: CandleInterval = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список свечей.
public struct GetCandlesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив свечей.
  public var candles: [HistoricCandle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о свече.
public struct HistoricCandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена открытия за 1 лот.
  public var `open`: Quotation {
    get {return _open ?? Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 лот.
  public var high: Quotation {
    get {return _high ?? Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 лот.
  public var low: Quotation {
    get {return _low ?? Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 лот.
  public var close: Quotation {
    get {return _close ?? Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объём торгов в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак завершённости свечи. **false** значит, свеча за текущие интервал ещё сформирована не полностью.
  public var isComplete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Quotation? = nil
  fileprivate var _high: Quotation? = nil
  fileprivate var _low: Quotation? = nil
  fileprivate var _close: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения последних цен.
public struct GetLastPricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив figi-идентификаторов инструментов.
  public var figi: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Список последних цен.
public struct GetLastPricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив последних цен.
  public var lastPrices: [LastPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о цене.
public struct LastPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var figi: String = String()

  ///Последняя цена за 1 лот.
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Время получения последней цены в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос стакана.
public struct GetOrderBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о стакане.
public struct GetOrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Множество пар значений на покупку.
  public var bids: [Order] = []

  ///Множество пар значений на продажу.
  public var asks: [Order] = []

  ///Цена последней сделки.
  public var lastPrice: Quotation {
    get {return _lastPrice ?? Quotation()}
    set {_lastPrice = newValue}
  }
  /// Returns true if `lastPrice` has been explicitly set.
  public var hasLastPrice: Bool {return self._lastPrice != nil}
  /// Clears the value of `lastPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLastPrice() {self._lastPrice = nil}

  ///Цена закрытия.
  public var closePrice: Quotation {
    get {return _closePrice ?? Quotation()}
    set {_closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return self._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {self._closePrice = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastPrice: Quotation? = nil
  fileprivate var _closePrice: Quotation? = nil
}

///Запрос получения торгового статуса.
public struct GetTradingStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct GetTradingStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension SubscriptionAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_ACTION_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_ACTION_SUBSCRIBE"),
    2: .same(proto: "SUBSCRIPTION_ACTION_UNSUBSCRIBE"),
  ]
}

extension SubscriptionInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "SUBSCRIPTION_INTERVAL_FIVE_MINUTES"),
  ]
}

extension SubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND"),
    3: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"),
    4: .same(proto: "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID"),
    5: .same(proto: "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID"),
    6: .same(proto: "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED"),
    7: .same(proto: "SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
  ]
}

extension TradeDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "TRADE_DIRECTION_BUY"),
    2: .same(proto: "TRADE_DIRECTION_SELL"),
  ]
}

extension CandleInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "CANDLE_INTERVAL_1_MIN"),
    2: .same(proto: "CANDLE_INTERVAL_5_MIN"),
    3: .same(proto: "CANDLE_INTERVAL_15_MIN"),
    4: .same(proto: "CANDLE_INTERVAL_HOUR"),
    5: .same(proto: "CANDLE_INTERVAL_DAY"),
  ]
}

extension MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesRequest(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookRequest(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesRequest(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesRequest?: try {
      guard case .subscribeCandlesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookRequest?: try {
      guard case .subscribeOrderBookRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesRequest?: try {
      guard case .subscribeTradesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoRequest?: try {
      guard case .subscribeInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataRequest, rhs: MarketDataRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_response"),
    2: .standard(proto: "subscribe_order_book_response"),
    3: .standard(proto: "subscribe_trades_response"),
    4: .standard(proto: "subscribe_info_response"),
    5: .same(proto: "candle"),
    6: .same(proto: "trade"),
    7: .same(proto: "orderbook"),
    8: .standard(proto: "trading_status"),
    9: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesResponse(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookResponse(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesResponse(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Candle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .candle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .candle(v)
        }
      }()
      case 6: try {
        var v: Trade?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 7: try {
        var v: OrderBook?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderbook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderbook(v)
        }
      }()
      case 8: try {
        var v: TradingStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tradingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tradingStatus(v)
        }
      }()
      case 9: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesResponse?: try {
      guard case .subscribeCandlesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookResponse?: try {
      guard case .subscribeOrderBookResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesResponse?: try {
      guard case .subscribeTradesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoResponse?: try {
      guard case .subscribeInfoResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .candle?: try {
      guard case .candle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orderbook?: try {
      guard case .orderbook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tradingStatus?: try {
      guard case .tradingStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataResponse, rhs: MarketDataResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesRequest, rhs: SubscribeCandlesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleInstrument, rhs: CandleInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "candles_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candlesSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.candlesSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candlesSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesResponse, rhs: SubscribeCandlesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.candlesSubscriptions != rhs.candlesSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleSubscription, rhs: CandleSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookRequest, rhs: SubscribeOrderBookRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookInstrument, rhs: OrderBookInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "order_book_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBookSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.orderBookSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBookSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookResponse, rhs: SubscribeOrderBookResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.orderBookSubscriptions != rhs.orderBookSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookSubscription, rhs: OrderBookSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesRequest, rhs: SubscribeTradesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeInstrument, rhs: TradeInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "trade_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradeSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.tradeSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesResponse, rhs: SubscribeTradesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.tradeSubscriptions != rhs.tradeSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeSubscription, rhs: TradeSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoRequest, rhs: SubscribeInfoRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoInstrument, rhs: InfoInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "info_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.infoSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoResponse, rhs: SubscribeInfoResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.infoSubscriptions != rhs.infoSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoSubscription, rhs: InfoSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Candle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .same(proto: "open"),
    4: .same(proto: "high"),
    5: .same(proto: "low"),
    6: .same(proto: "close"),
    7: .same(proto: "volume"),
    8: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 7)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Candle, rhs: Candle) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "is_consistent"),
    4: .same(proto: "bids"),
    5: .same(proto: "asks"),
    6: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConsistent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.isConsistent != false {
      try visitor.visitSingularBoolField(value: self.isConsistent, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBook, rhs: OrderBook) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.isConsistent != rhs.isConsistent {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order, rhs: Order) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "direction"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trade, rhs: Trade) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingStatus, rhs: TradingStatus) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesRequest, rhs: GetCandlesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.candles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesResponse, rhs: GetCandlesResponse) -> Bool {
    if lhs.candles != rhs.candles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HistoricCandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricCandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "high"),
    3: .same(proto: "low"),
    4: .same(proto: "close"),
    5: .same(proto: "volume"),
    6: .same(proto: "time"),
    7: .standard(proto: "is_complete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HistoricCandle, rhs: HistoricCandle) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitRepeatedStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesRequest, rhs: GetLastPricesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesResponse, rhs: GetLastPricesResponse) -> Bool {
    if lhs.lastPrices != rhs.lastPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPrice, rhs: LastPrice) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookRequest, rhs: GetOrderBookRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .same(proto: "bids"),
    4: .same(proto: "asks"),
    5: .standard(proto: "last_price"),
    6: .standard(proto: "close_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastPrice) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._closePrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 3)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 4)
    }
    try { if let v = self._lastPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._closePrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookResponse, rhs: GetOrderBookResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._lastPrice != rhs._lastPrice {return false}
    if lhs._closePrice != rhs._closePrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusRequest, rhs: GetTradingStatusRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusResponse, rhs: GetTradingStatusResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
