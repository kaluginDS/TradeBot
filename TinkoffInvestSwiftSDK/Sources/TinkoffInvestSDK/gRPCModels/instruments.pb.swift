// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: instruments.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип идентификатора инструмента. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
public enum InstrumentIdType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case instrumentIDUnspecified // = 0

  ///Figi.
  case figi // = 1

  ///Ticker.
  case ticker // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .instrumentIDUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .instrumentIDUnspecified
    case 1: self = .figi
    case 2: self = .ticker
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .instrumentIDUnspecified: return 0
    case .figi: return 1
    case .ticker: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InstrumentIdType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InstrumentIdType] = [
    .instrumentIDUnspecified,
    .figi,
    .ticker,
  ]
}

#endif  // swift(>=4.2)

///Статус запрашиваемых инструментов.
public enum InstrumentStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case unspecified // = 0

  ///Базовый список инструментов (по умолчанию). Инструменты доступные для торговли через TINKOFF INVEST API.
  case base // = 1

  ///Список всех инструментов.
  case all // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .base
    case 2: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .base: return 1
    case .all: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InstrumentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InstrumentStatus] = [
    .unspecified,
    .base,
    .all,
  ]
}

#endif  // swift(>=4.2)

///Тип акций.
public enum ShareType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Значение не определено.
  case unspecified // = 0

  ///Обыкновенная
  case common // = 1

  ///Привилегированная
  case preferred // = 2

  ///Американские депозитарные расписки
  case adr // = 3

  ///Глобальные депозитарные расписки
  case gdr // = 4

  ///Товарищество с ограниченной ответственностью
  case mlp // = 5

  ///Акции из реестра Нью-Йорка
  case nyRegShrs // = 6

  ///Закрытый инвестиционный фонд
  case closedEndFund // = 7

  ///Траст недвижимости
  case reit // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .common
    case 2: self = .preferred
    case 3: self = .adr
    case 4: self = .gdr
    case 5: self = .mlp
    case 6: self = .nyRegShrs
    case 7: self = .closedEndFund
    case 8: self = .reit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .common: return 1
    case .preferred: return 2
    case .adr: return 3
    case .gdr: return 4
    case .mlp: return 5
    case .nyRegShrs: return 6
    case .closedEndFund: return 7
    case .reit: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ShareType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ShareType] = [
    .unspecified,
    .common,
    .preferred,
    .adr,
    .gdr,
    .mlp,
    .nyRegShrs,
    .closedEndFund,
    .reit,
  ]
}

#endif  // swift(>=4.2)

///Запрос расписания торгов
public struct TradingSchedulesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Наименование биржи или расчетного календаря. </br>Если не передаётся, возвращается информация по всем доступным торговым площадкам.
  public var exchange: String = String()

  ///Начало периода по часовому поясу UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание периода по часовому поясу UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Список торговых площадок
public struct TradingSchedulesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Список торговых площадок и режимов торгов.
  public var exchanges: [TradingSchedule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по торговой площадке.
public struct TradingSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Наименование торговой площадки.
  public var exchange: String = String()

  /// Массив с торговыми и неторговыми днями.
  public var days: [TradingDay] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о времени торгов.
public struct TradingDay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Дата.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// Признак торгового дня на бирже.
  public var isTradingDay: Bool = false

  /// Время начала торгов по часовому поясу UTC.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Время окончания торгов по часовому поясу UTC.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Время начала подачи заявки по часовому поясу UTC.
  public var marketOrderStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _marketOrderStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_marketOrderStartTime = newValue}
  }
  /// Returns true if `marketOrderStartTime` has been explicitly set.
  public var hasMarketOrderStartTime: Bool {return self._marketOrderStartTime != nil}
  /// Clears the value of `marketOrderStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearMarketOrderStartTime() {self._marketOrderStartTime = nil}

  /// Время окончания подачи заявки по часовому поясу UTC.
  public var marketOrderEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _marketOrderEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_marketOrderEndTime = newValue}
  }
  /// Returns true if `marketOrderEndTime` has been explicitly set.
  public var hasMarketOrderEndTime: Bool {return self._marketOrderEndTime != nil}
  /// Clears the value of `marketOrderEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearMarketOrderEndTime() {self._marketOrderEndTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _marketOrderStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _marketOrderEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения инструмента по идентификатору.
public struct InstrumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Тип идентификатора инструмента. Возможные значения: figi, ticker, isin. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
  public var idType: InstrumentIdType = .instrumentIDUnspecified

  /// Идентификатор class_code. Обязателен при id_type = ticker.
  public var classCode: String = String()

  /// Идентификатор запрашиваемого инструмента.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос получения инструментов.
public struct InstrumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Статус запрашиваемых инструментов. Возможные значения: [InstrumentStatus](#instrumentstatus)
  public var instrumentStatus: InstrumentStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация об облигации.
public struct BondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация об облигации.
  public var instrument: Bond {
    get {return _instrument ?? Bond()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Bond? = nil
}

///Список облигаций.
public struct BondsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив облигаций.
  public var instruments: [Bond] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по валюте.
public struct CurrencyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о валюте.
  public var instrument: Currency {
    get {return _instrument ?? Currency()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Currency? = nil
}

///Данные по валютам.
public struct CurrenciesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив валют.
  public var instruments: [Currency] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фонду.
public struct EtfResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о фонде.
  public var instrument: Etf {
    get {return _instrument ?? Etf()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Etf? = nil
}

///Данные по фондам.
public struct EtfsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив фондов.
  public var instruments: [Etf] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фьючерсу.
public struct FutureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация о фьючерсу.
  public var instrument: Future {
    get {return _instrument ?? Future()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Future? = nil
}

///Данные по фьючерсам.
public struct FuturesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив фьючерсов.
  public var instruments: [Future] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по акции.
public struct ShareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Информация об акции.
  public var instrument: Share {
    get {return _instrument ?? Share()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Share? = nil
}

///Данные по акциям.
public struct SharesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив акций.
  public var instruments: [Share] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Объект передачи информации об облигации.
public struct Bond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Количество выплат по купонам в год.
  public var couponQuantityPerYear: Int32 {
    get {return _storage._couponQuantityPerYear}
    set {_uniqueStorage()._couponQuantityPerYear = newValue}
  }

  ///Дата погашения облигации в часовом поясе UTC.
  public var maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maturityDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maturityDate = newValue}
  }
  /// Returns true if `maturityDate` has been explicitly set.
  public var hasMaturityDate: Bool {return _storage._maturityDate != nil}
  /// Clears the value of `maturityDate`. Subsequent reads from it will return its default value.
  public mutating func clearMaturityDate() {_uniqueStorage()._maturityDate = nil}

  ///Номинал облигации.
  public var nominal: MoneyValue {
    get {return _storage._nominal ?? MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Дата выпуска облигации в часовом поясе UTC.
  public var stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._stateRegDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._stateRegDate = newValue}
  }
  /// Returns true if `stateRegDate` has been explicitly set.
  public var hasStateRegDate: Bool {return _storage._stateRegDate != nil}
  /// Clears the value of `stateRegDate`. Subsequent reads from it will return its default value.
  public mutating func clearStateRegDate() {_uniqueStorage()._stateRegDate = nil}

  ///Дата размещения в часовом поясе UTC.
  public var placementDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._placementDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._placementDate = newValue}
  }
  /// Returns true if `placementDate` has been explicitly set.
  public var hasPlacementDate: Bool {return _storage._placementDate != nil}
  /// Clears the value of `placementDate`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementDate() {_uniqueStorage()._placementDate = nil}

  ///Цена размещения.
  public var placementPrice: MoneyValue {
    get {return _storage._placementPrice ?? MoneyValue()}
    set {_uniqueStorage()._placementPrice = newValue}
  }
  /// Returns true if `placementPrice` has been explicitly set.
  public var hasPlacementPrice: Bool {return _storage._placementPrice != nil}
  /// Clears the value of `placementPrice`. Subsequent reads from it will return its default value.
  public mutating func clearPlacementPrice() {_uniqueStorage()._placementPrice = nil}

  ///Значение НКД (накопленного купонного дохода) на дату.
  public var aciValue: MoneyValue {
    get {return _storage._aciValue ?? MoneyValue()}
    set {_uniqueStorage()._aciValue = newValue}
  }
  /// Returns true if `aciValue` has been explicitly set.
  public var hasAciValue: Bool {return _storage._aciValue != nil}
  /// Clears the value of `aciValue`. Subsequent reads from it will return its default value.
  public mutating func clearAciValue() {_uniqueStorage()._aciValue = nil}

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Форма выпуска. Возможные значения: </br>**documentary** — документарная; </br>**non_documentary** — бездокументарная.
  public var issueKind: String {
    get {return _storage._issueKind}
    set {_uniqueStorage()._issueKind = newValue}
  }

  ///Размер выпуска.
  public var issueSize: Int64 {
    get {return _storage._issueSize}
    set {_uniqueStorage()._issueSize = newValue}
  }

  ///Плановый размер выпуска.
  public var issueSizePlan: Int64 {
    get {return _storage._issueSizePlan}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Признак облигации с плавающим купоном.
  public var floatingCouponFlag: Bool {
    get {return _storage._floatingCouponFlag}
    set {_uniqueStorage()._floatingCouponFlag = newValue}
  }

  ///Признак бессрочной облигации.
  public var perpetualFlag: Bool {
    get {return _storage._perpetualFlag}
    set {_uniqueStorage()._perpetualFlag = newValue}
  }

  ///Признак облигации с амортизацией долга.
  public var amortizationFlag: Bool {
    get {return _storage._amortizationFlag}
    set {_uniqueStorage()._amortizationFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации о валюте.
public struct Currency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Номинал.
  public var nominal: MoneyValue {
    get {return _storage._nominal ?? MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Строковый ISO-код валюты.
  public var isoCurrencyName: String {
    get {return _storage._isoCurrencyName}
    set {_uniqueStorage()._isoCurrencyName = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации об инвестиционном фонде.
public struct Etf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Размер фиксированной комиссии фонда.
  public var fixedCommission: Quotation {
    get {return _storage._fixedCommission ?? Quotation()}
    set {_uniqueStorage()._fixedCommission = newValue}
  }
  /// Returns true if `fixedCommission` has been explicitly set.
  public var hasFixedCommission: Bool {return _storage._fixedCommission != nil}
  /// Clears the value of `fixedCommission`. Subsequent reads from it will return its default value.
  public mutating func clearFixedCommission() {_uniqueStorage()._fixedCommission = nil}

  ///Возможные значения: </br>**equity** — акции;</br>**fixed_income** — облигации;</br>**mixed_allocation** — смешанный;</br>**money_market** — денежный рынок;</br>**real_estate** — недвижимость;</br>**commodity** — товары;</br>**specialty** — специальный;</br>**private_equity** — private equity;</br>**alternative_investment** — альтернативные инвестиции.
  public var focusType: String {
    get {return _storage._focusType}
    set {_uniqueStorage()._focusType = newValue}
  }

  ///Дата выпуска в часовом поясе UTC.
  public var releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._releasedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._releasedDate = newValue}
  }
  /// Returns true if `releasedDate` has been explicitly set.
  public var hasReleasedDate: Bool {return _storage._releasedDate != nil}
  /// Clears the value of `releasedDate`. Subsequent reads from it will return its default value.
  public mutating func clearReleasedDate() {_uniqueStorage()._releasedDate = nil}

  ///Количество акций фонда в обращении.
  public var numShares: Quotation {
    get {return _storage._numShares ?? Quotation()}
    set {_uniqueStorage()._numShares = newValue}
  }
  /// Returns true if `numShares` has been explicitly set.
  public var hasNumShares: Bool {return _storage._numShares != nil}
  /// Clears the value of `numShares`. Subsequent reads from it will return its default value.
  public mutating func clearNumShares() {_uniqueStorage()._numShares = nil}

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Частота ребалансировки.
  public var rebalancingFreq: String {
    get {return _storage._rebalancingFreq}
    set {_uniqueStorage()._rebalancingFreq = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации о фьючерсе.
public struct Future {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по клиенту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по клиенту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Дата начала обращения контракта в часовом поясе UTC.
  public var firstTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstTradeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstTradeDate = newValue}
  }
  /// Returns true if `firstTradeDate` has been explicitly set.
  public var hasFirstTradeDate: Bool {return _storage._firstTradeDate != nil}
  /// Clears the value of `firstTradeDate`. Subsequent reads from it will return its default value.
  public mutating func clearFirstTradeDate() {_uniqueStorage()._firstTradeDate = nil}

  ///Дата в часовом поясе UTC, до которой возможно проведение операций с фьючерсом.
  public var lastTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastTradeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastTradeDate = newValue}
  }
  /// Returns true if `lastTradeDate` has been explicitly set.
  public var hasLastTradeDate: Bool {return _storage._lastTradeDate != nil}
  /// Clears the value of `lastTradeDate`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeDate() {_uniqueStorage()._lastTradeDate = nil}

  ///Тип фьючерса. Возможные значения: </br>**physical_delivery** — физические поставки; </br>**cash_settlement** — денежный эквивалент.
  public var futuresType: String {
    get {return _storage._futuresType}
    set {_uniqueStorage()._futuresType = newValue}
  }

  ///Тип актива. Возможные значения: </br>**commodity** — товар; </br>**currency** — валюта; </br>**security** — ценная бумага; </br>**index** — индекс.
  public var assetType: String {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  ///Основной актив.
  public var basicAsset: String {
    get {return _storage._basicAsset}
    set {_uniqueStorage()._basicAsset = newValue}
  }

  ///Размер основного актива.
  public var basicAssetSize: Quotation {
    get {return _storage._basicAssetSize ?? Quotation()}
    set {_uniqueStorage()._basicAssetSize = newValue}
  }
  /// Returns true if `basicAssetSize` has been explicitly set.
  public var hasBasicAssetSize: Bool {return _storage._basicAssetSize != nil}
  /// Clears the value of `basicAssetSize`. Subsequent reads from it will return its default value.
  public mutating func clearBasicAssetSize() {_uniqueStorage()._basicAssetSize = nil}

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Дата истечения срока.
  public var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  public var hasExpirationDate: Bool {return _storage._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationDate() {_uniqueStorage()._expirationDate = nil}

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Объект передачи информации об акции.
public struct Share {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код (секция торгов).
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Дата IPO акции в часовом поясе UTC.
  public var ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._ipoDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._ipoDate = newValue}
  }
  /// Returns true if `ipoDate` has been explicitly set.
  public var hasIpoDate: Bool {return _storage._ipoDate != nil}
  /// Clears the value of `ipoDate`. Subsequent reads from it will return its default value.
  public mutating func clearIpoDate() {_uniqueStorage()._ipoDate = nil}

  ///Размер выпуска.
  public var issueSize: Int64 {
    get {return _storage._issueSize}
    set {_uniqueStorage()._issueSize = newValue}
  }

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Сектор экономики.
  public var sector: String {
    get {return _storage._sector}
    set {_uniqueStorage()._sector = newValue}
  }

  ///Плановый размер выпуска.
  public var issueSizePlan: Int64 {
    get {return _storage._issueSizePlan}
    set {_uniqueStorage()._issueSizePlan = newValue}
  }

  ///Номинал.
  public var nominal: MoneyValue {
    get {return _storage._nominal ?? MoneyValue()}
    set {_uniqueStorage()._nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return _storage._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {_uniqueStorage()._nominal = nil}

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Признак наличия дивидендной доходности.
  public var divYieldFlag: Bool {
    get {return _storage._divYieldFlag}
    set {_uniqueStorage()._divYieldFlag = newValue}
  }

  ///Тип акции. Возможные значения: [ShareType](https://tinkoff.github.io/investAPI/instruments#sharetype)
  public var shareType: ShareType {
    get {return _storage._shareType}
    set {_uniqueStorage()._shareType = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос НКД по облигации
public struct GetAccruedInterestsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///НКД облигации
public struct GetAccruedInterestsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив операций начисления купонов.
  public var accruedInterests: [AccruedInterest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Операция начисления купонов.
public struct AccruedInterest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Дата и время выплаты в часовом поясе UTC.
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  ///Величина выплаты.
  public var value: Quotation {
    get {return _value ?? Quotation()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  ///Величина выплаты в процентах от номинала.
  public var valuePercent: Quotation {
    get {return _valuePercent ?? Quotation()}
    set {_valuePercent = newValue}
  }
  /// Returns true if `valuePercent` has been explicitly set.
  public var hasValuePercent: Bool {return self._valuePercent != nil}
  /// Clears the value of `valuePercent`. Subsequent reads from it will return its default value.
  public mutating func clearValuePercent() {self._valuePercent = nil}

  ///Номинал облигации.
  public var nominal: Quotation {
    get {return _nominal ?? Quotation()}
    set {_nominal = newValue}
  }
  /// Returns true if `nominal` has been explicitly set.
  public var hasNominal: Bool {return self._nominal != nil}
  /// Clears the value of `nominal`. Subsequent reads from it will return its default value.
  public mutating func clearNominal() {self._nominal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _value: Quotation? = nil
  fileprivate var _valuePercent: Quotation? = nil
  fileprivate var _nominal: Quotation? = nil
}

///Запрос информации о фьючерсе
public struct GetFuturesMarginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Идентификатор инструмента.
  public var figi: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Данные по фьючерсу
public struct GetFuturesMarginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Гарантийное обеспечение при покупке.
  public var initialMarginOnBuy: MoneyValue {
    get {return _initialMarginOnBuy ?? MoneyValue()}
    set {_initialMarginOnBuy = newValue}
  }
  /// Returns true if `initialMarginOnBuy` has been explicitly set.
  public var hasInitialMarginOnBuy: Bool {return self._initialMarginOnBuy != nil}
  /// Clears the value of `initialMarginOnBuy`. Subsequent reads from it will return its default value.
  public mutating func clearInitialMarginOnBuy() {self._initialMarginOnBuy = nil}

  ///Гарантийное обеспечение при продаже.
  public var initialMarginOnSell: MoneyValue {
    get {return _initialMarginOnSell ?? MoneyValue()}
    set {_initialMarginOnSell = newValue}
  }
  /// Returns true if `initialMarginOnSell` has been explicitly set.
  public var hasInitialMarginOnSell: Bool {return self._initialMarginOnSell != nil}
  /// Clears the value of `initialMarginOnSell`. Subsequent reads from it will return its default value.
  public mutating func clearInitialMarginOnSell() {self._initialMarginOnSell = nil}

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _minPriceIncrement ?? Quotation()}
    set {_minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return self._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {self._minPriceIncrement = nil}

  ///Стоимость шага цены.
  public var minPriceIncrementAmount: Quotation {
    get {return _minPriceIncrementAmount ?? Quotation()}
    set {_minPriceIncrementAmount = newValue}
  }
  /// Returns true if `minPriceIncrementAmount` has been explicitly set.
  public var hasMinPriceIncrementAmount: Bool {return self._minPriceIncrementAmount != nil}
  /// Clears the value of `minPriceIncrementAmount`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrementAmount() {self._minPriceIncrementAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialMarginOnBuy: MoneyValue? = nil
  fileprivate var _initialMarginOnSell: MoneyValue? = nil
  fileprivate var _minPriceIncrement: Quotation? = nil
  fileprivate var _minPriceIncrementAmount: Quotation? = nil
}

///Данные по инструменту.
public struct InstrumentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Основная информация об инструменте.
  public var instrument: Instrument {
    get {return _instrument ?? Instrument()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  public var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  public mutating func clearInstrument() {self._instrument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrument: Instrument? = nil
}

///Объект передачи основной информации об инструменте.
public struct Instrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Тикер инструмента.
  public var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  ///Класс-код инструмента.
  public var classCode: String {
    get {return _storage._classCode}
    set {_uniqueStorage()._classCode = newValue}
  }

  ///Isin-идентификатор инструмента.
  public var isin: String {
    get {return _storage._isin}
    set {_uniqueStorage()._isin = newValue}
  }

  ///Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
  public var lot: Int32 {
    get {return _storage._lot}
    set {_uniqueStorage()._lot = newValue}
  }

  ///Валюта расчётов.
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///Коэффициент ставки риска длинной позиции по инструменту.
  public var klong: Quotation {
    get {return _storage._klong ?? Quotation()}
    set {_uniqueStorage()._klong = newValue}
  }
  /// Returns true if `klong` has been explicitly set.
  public var hasKlong: Bool {return _storage._klong != nil}
  /// Clears the value of `klong`. Subsequent reads from it will return its default value.
  public mutating func clearKlong() {_uniqueStorage()._klong = nil}

  ///Коэффициент ставки риска короткой позиции по инструменту.
  public var kshort: Quotation {
    get {return _storage._kshort ?? Quotation()}
    set {_uniqueStorage()._kshort = newValue}
  }
  /// Returns true if `kshort` has been explicitly set.
  public var hasKshort: Bool {return _storage._kshort != nil}
  /// Clears the value of `kshort`. Subsequent reads from it will return its default value.
  public mutating func clearKshort() {_uniqueStorage()._kshort = nil}

  ///Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlong: Quotation {
    get {return _storage._dlong ?? Quotation()}
    set {_uniqueStorage()._dlong = newValue}
  }
  /// Returns true if `dlong` has been explicitly set.
  public var hasDlong: Bool {return _storage._dlong != nil}
  /// Clears the value of `dlong`. Subsequent reads from it will return its default value.
  public mutating func clearDlong() {_uniqueStorage()._dlong = nil}

  ///Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshort: Quotation {
    get {return _storage._dshort ?? Quotation()}
    set {_uniqueStorage()._dshort = newValue}
  }
  /// Returns true if `dshort` has been explicitly set.
  public var hasDshort: Bool {return _storage._dshort != nil}
  /// Clears the value of `dshort`. Subsequent reads from it will return its default value.
  public mutating func clearDshort() {_uniqueStorage()._dshort = nil}

  ///Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
  public var dlongMin: Quotation {
    get {return _storage._dlongMin ?? Quotation()}
    set {_uniqueStorage()._dlongMin = newValue}
  }
  /// Returns true if `dlongMin` has been explicitly set.
  public var hasDlongMin: Bool {return _storage._dlongMin != nil}
  /// Clears the value of `dlongMin`. Subsequent reads from it will return its default value.
  public mutating func clearDlongMin() {_uniqueStorage()._dlongMin = nil}

  ///Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
  public var dshortMin: Quotation {
    get {return _storage._dshortMin ?? Quotation()}
    set {_uniqueStorage()._dshortMin = newValue}
  }
  /// Returns true if `dshortMin` has been explicitly set.
  public var hasDshortMin: Bool {return _storage._dshortMin != nil}
  /// Clears the value of `dshortMin`. Subsequent reads from it will return its default value.
  public mutating func clearDshortMin() {_uniqueStorage()._dshortMin = nil}

  ///Признак доступности для операций в шорт.
  public var shortEnabledFlag: Bool {
    get {return _storage._shortEnabledFlag}
    set {_uniqueStorage()._shortEnabledFlag = newValue}
  }

  ///Название инструмента.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///Торговая площадка.
  public var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  ///Код страны эмитента.
  public var countryOfRisk: String {
    get {return _storage._countryOfRisk}
    set {_uniqueStorage()._countryOfRisk = newValue}
  }

  ///Наименование страны эмитента.
  public var countryOfRiskName: String {
    get {return _storage._countryOfRiskName}
    set {_uniqueStorage()._countryOfRiskName = newValue}
  }

  ///Тип инструмента.
  public var instrumentType: String {
    get {return _storage._instrumentType}
    set {_uniqueStorage()._instrumentType = newValue}
  }

  ///Текущий режим торгов инструмента.
  public var tradingStatus: SecurityTradingStatus {
    get {return _storage._tradingStatus}
    set {_uniqueStorage()._tradingStatus = newValue}
  }

  ///Признак внебиржевой ценной бумаги.
  public var otcFlag: Bool {
    get {return _storage._otcFlag}
    set {_uniqueStorage()._otcFlag = newValue}
  }

  ///Признак доступности для покупки.
  public var buyAvailableFlag: Bool {
    get {return _storage._buyAvailableFlag}
    set {_uniqueStorage()._buyAvailableFlag = newValue}
  }

  ///Признак доступности для продажи.
  public var sellAvailableFlag: Bool {
    get {return _storage._sellAvailableFlag}
    set {_uniqueStorage()._sellAvailableFlag = newValue}
  }

  ///Шаг цены.
  public var minPriceIncrement: Quotation {
    get {return _storage._minPriceIncrement ?? Quotation()}
    set {_uniqueStorage()._minPriceIncrement = newValue}
  }
  /// Returns true if `minPriceIncrement` has been explicitly set.
  public var hasMinPriceIncrement: Bool {return _storage._minPriceIncrement != nil}
  /// Clears the value of `minPriceIncrement`. Subsequent reads from it will return its default value.
  public mutating func clearMinPriceIncrement() {_uniqueStorage()._minPriceIncrement = nil}

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool {
    get {return _storage._apiTradeAvailableFlag}
    set {_uniqueStorage()._apiTradeAvailableFlag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос дивидендов.
public struct GetDividendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Figi-идентификатор инструмента.
  public var figi: String = String()

  ///Начало запрашиваемого периода в часовом поясе UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода в часовом поясе UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Дивиденды.
public struct GetDividendsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dividends: [Dividend] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о выплате.
public struct Dividend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Величина дивиденда на 1 ценную бумагу (включая валюту).
  public var dividendNet: MoneyValue {
    get {return _storage._dividendNet ?? MoneyValue()}
    set {_uniqueStorage()._dividendNet = newValue}
  }
  /// Returns true if `dividendNet` has been explicitly set.
  public var hasDividendNet: Bool {return _storage._dividendNet != nil}
  /// Clears the value of `dividendNet`. Subsequent reads from it will return its default value.
  public mutating func clearDividendNet() {_uniqueStorage()._dividendNet = nil}

  ///Дата фактических выплат.
  public var paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._paymentDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._paymentDate = newValue}
  }
  /// Returns true if `paymentDate` has been explicitly set.
  public var hasPaymentDate: Bool {return _storage._paymentDate != nil}
  /// Clears the value of `paymentDate`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentDate() {_uniqueStorage()._paymentDate = nil}

  ///Дата объявления дивидендов.
  public var declaredDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._declaredDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._declaredDate = newValue}
  }
  /// Returns true if `declaredDate` has been explicitly set.
  public var hasDeclaredDate: Bool {return _storage._declaredDate != nil}
  /// Clears the value of `declaredDate`. Subsequent reads from it will return its default value.
  public mutating func clearDeclaredDate() {_uniqueStorage()._declaredDate = nil}

  ///Последний день (включительно) покупки для получения выплаты.
  public var lastBuyDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastBuyDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastBuyDate = newValue}
  }
  /// Returns true if `lastBuyDate` has been explicitly set.
  public var hasLastBuyDate: Bool {return _storage._lastBuyDate != nil}
  /// Clears the value of `lastBuyDate`. Subsequent reads from it will return its default value.
  public mutating func clearLastBuyDate() {_uniqueStorage()._lastBuyDate = nil}

  ///Тип выплаты. Возможные значения: Regular Cash – регулярные выплаты, Cancelled – выплата отменена, Daily Accrual – ежедневное начисление, Return of Capital – возврат капитала, прочие типы выплат.
  public var dividendType: String {
    get {return _storage._dividendType}
    set {_uniqueStorage()._dividendType = newValue}
  }

  ///Дата фиксации реестра
  public var recordDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._recordDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._recordDate = newValue}
  }
  /// Returns true if `recordDate` has been explicitly set.
  public var hasRecordDate: Bool {return _storage._recordDate != nil}
  /// Clears the value of `recordDate`. Subsequent reads from it will return its default value.
  public mutating func clearRecordDate() {_uniqueStorage()._recordDate = nil}

  ///Регулярность выплаты. Возможные значения: Annual – ежегодная, Semi-Anl – каждые полгода, прочие типы выплат.
  public var regularity: String {
    get {return _storage._regularity}
    set {_uniqueStorage()._regularity = newValue}
  }

  ///Цена закрытия инструмента на момент ex_dividend_date.
  public var closePrice: MoneyValue {
    get {return _storage._closePrice ?? MoneyValue()}
    set {_uniqueStorage()._closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return _storage._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {_uniqueStorage()._closePrice = nil}

  ///Величина доходности.
  public var yieldValue: Quotation {
    get {return _storage._yieldValue ?? Quotation()}
    set {_uniqueStorage()._yieldValue = newValue}
  }
  /// Returns true if `yieldValue` has been explicitly set.
  public var hasYieldValue: Bool {return _storage._yieldValue != nil}
  /// Clears the value of `yieldValue`. Subsequent reads from it will return its default value.
  public mutating func clearYieldValue() {_uniqueStorage()._yieldValue = nil}

  ///Дата и время создания записи.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension InstrumentIdType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_ID_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_ID_TYPE_FIGI"),
    2: .same(proto: "INSTRUMENT_ID_TYPE_TICKER"),
  ]
}

extension InstrumentStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_STATUS_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_STATUS_BASE"),
    2: .same(proto: "INSTRUMENT_STATUS_ALL"),
  ]
}

extension ShareType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHARE_TYPE_UNSPECIFIED"),
    1: .same(proto: "SHARE_TYPE_COMMON"),
    2: .same(proto: "SHARE_TYPE_PREFERRED"),
    3: .same(proto: "SHARE_TYPE_ADR"),
    4: .same(proto: "SHARE_TYPE_GDR"),
    5: .same(proto: "SHARE_TYPE_MLP"),
    6: .same(proto: "SHARE_TYPE_NY_REG_SHRS"),
    7: .same(proto: "SHARE_TYPE_CLOSED_END_FUND"),
    8: .same(proto: "SHARE_TYPE_REIT"),
  ]
}

extension TradingSchedulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedulesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchange"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.exchange.isEmpty {
      try visitor.visitSingularStringField(value: self.exchange, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingSchedulesRequest, rhs: TradingSchedulesRequest) -> Bool {
    if lhs.exchange != rhs.exchange {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingSchedulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedulesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchanges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exchanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exchanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingSchedulesResponse, rhs: TradingSchedulesResponse) -> Bool {
    if lhs.exchanges != rhs.exchanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchange"),
    2: .same(proto: "days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchange) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.days) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchange.isEmpty {
      try visitor.visitSingularStringField(value: self.exchange, fieldNumber: 1)
    }
    if !self.days.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.days, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingSchedule, rhs: TradingSchedule) -> Bool {
    if lhs.exchange != rhs.exchange {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "is_trading_day"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
    5: .standard(proto: "market_order_start_time"),
    6: .standard(proto: "market_order_end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTradingDay) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._marketOrderStartTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._marketOrderEndTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isTradingDay != false {
      try visitor.visitSingularBoolField(value: self.isTradingDay, fieldNumber: 2)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._marketOrderStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._marketOrderEndTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingDay, rhs: TradingDay) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs.isTradingDay != rhs.isTradingDay {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._marketOrderStartTime != rhs._marketOrderStartTime {return false}
    if lhs._marketOrderEndTime != rhs._marketOrderEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_type"),
    2: .standard(proto: "class_code"),
    3: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.idType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idType != .instrumentIDUnspecified {
      try visitor.visitSingularEnumField(value: self.idType, fieldNumber: 1)
    }
    if !self.classCode.isEmpty {
      try visitor.visitSingularStringField(value: self.classCode, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentRequest, rhs: InstrumentRequest) -> Bool {
    if lhs.idType != rhs.idType {return false}
    if lhs.classCode != rhs.classCode {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.instrumentStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.instrumentStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.instrumentStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentsRequest, rhs: InstrumentsRequest) -> Bool {
    if lhs.instrumentStatus != rhs.instrumentStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BondResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BondResponse, rhs: BondResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BondsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BondsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BondsResponse, rhs: BondsResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CurrencyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrencyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CurrencyResponse, rhs: CurrencyResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CurrenciesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrenciesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CurrenciesResponse, rhs: CurrenciesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EtfResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EtfResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EtfResponse, rhs: EtfResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EtfsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EtfsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EtfsResponse, rhs: EtfsResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FutureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FutureResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FutureResponse, rhs: FutureResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FuturesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FuturesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FuturesResponse, rhs: FuturesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShareResponse, rhs: ShareResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SharesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SharesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SharesResponse, rhs: SharesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bond"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "coupon_quantity_per_year"),
    18: .standard(proto: "maturity_date"),
    19: .same(proto: "nominal"),
    21: .standard(proto: "state_reg_date"),
    22: .standard(proto: "placement_date"),
    23: .standard(proto: "placement_price"),
    24: .standard(proto: "aci_value"),
    25: .standard(proto: "country_of_risk"),
    26: .standard(proto: "country_of_risk_name"),
    27: .same(proto: "sector"),
    28: .standard(proto: "issue_kind"),
    29: .standard(proto: "issue_size"),
    30: .standard(proto: "issue_size_plan"),
    31: .standard(proto: "trading_status"),
    32: .standard(proto: "otc_flag"),
    33: .standard(proto: "buy_available_flag"),
    34: .standard(proto: "sell_available_flag"),
    35: .standard(proto: "floating_coupon_flag"),
    36: .standard(proto: "perpetual_flag"),
    37: .standard(proto: "amortization_flag"),
    38: .standard(proto: "min_price_increment"),
    39: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _couponQuantityPerYear: Int32 = 0
    var _maturityDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nominal: MoneyValue? = nil
    var _stateRegDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _placementPrice: MoneyValue? = nil
    var _aciValue: MoneyValue? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _issueKind: String = String()
    var _issueSize: Int64 = 0
    var _issueSizePlan: Int64 = 0
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _floatingCouponFlag: Bool = false
    var _perpetualFlag: Bool = false
    var _amortizationFlag: Bool = false
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _couponQuantityPerYear = source._couponQuantityPerYear
      _maturityDate = source._maturityDate
      _nominal = source._nominal
      _stateRegDate = source._stateRegDate
      _placementDate = source._placementDate
      _placementPrice = source._placementPrice
      _aciValue = source._aciValue
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _issueKind = source._issueKind
      _issueSize = source._issueSize
      _issueSizePlan = source._issueSizePlan
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _floatingCouponFlag = source._floatingCouponFlag
      _perpetualFlag = source._perpetualFlag
      _amortizationFlag = source._amortizationFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._couponQuantityPerYear) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._maturityDate) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._stateRegDate) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._placementDate) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._placementPrice) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._aciValue) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._issueKind) }()
        case 29: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSize) }()
        case 30: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSizePlan) }()
        case 31: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 35: try { try decoder.decodeSingularBoolField(value: &_storage._floatingCouponFlag) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._perpetualFlag) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._amortizationFlag) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      if _storage._couponQuantityPerYear != 0 {
        try visitor.visitSingularInt32Field(value: _storage._couponQuantityPerYear, fieldNumber: 17)
      }
      try { if let v = _storage._maturityDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._stateRegDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._placementDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._placementPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._aciValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 25)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 26)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 27)
      }
      if !_storage._issueKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueKind, fieldNumber: 28)
      }
      if _storage._issueSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSize, fieldNumber: 29)
      }
      if _storage._issueSizePlan != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSizePlan, fieldNumber: 30)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 31)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 32)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 33)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 34)
      }
      if _storage._floatingCouponFlag != false {
        try visitor.visitSingularBoolField(value: _storage._floatingCouponFlag, fieldNumber: 35)
      }
      if _storage._perpetualFlag != false {
        try visitor.visitSingularBoolField(value: _storage._perpetualFlag, fieldNumber: 36)
      }
      if _storage._amortizationFlag != false {
        try visitor.visitSingularBoolField(value: _storage._amortizationFlag, fieldNumber: 37)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 39)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bond, rhs: Bond) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._couponQuantityPerYear != rhs_storage._couponQuantityPerYear {return false}
        if _storage._maturityDate != rhs_storage._maturityDate {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._stateRegDate != rhs_storage._stateRegDate {return false}
        if _storage._placementDate != rhs_storage._placementDate {return false}
        if _storage._placementPrice != rhs_storage._placementPrice {return false}
        if _storage._aciValue != rhs_storage._aciValue {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._issueKind != rhs_storage._issueKind {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._floatingCouponFlag != rhs_storage._floatingCouponFlag {return false}
        if _storage._perpetualFlag != rhs_storage._perpetualFlag {return false}
        if _storage._amortizationFlag != rhs_storage._amortizationFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Currency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Currency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .same(proto: "nominal"),
    18: .standard(proto: "country_of_risk"),
    19: .standard(proto: "country_of_risk_name"),
    20: .standard(proto: "trading_status"),
    21: .standard(proto: "otc_flag"),
    22: .standard(proto: "buy_available_flag"),
    23: .standard(proto: "sell_available_flag"),
    24: .standard(proto: "iso_currency_name"),
    25: .standard(proto: "min_price_increment"),
    26: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _nominal: MoneyValue? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _isoCurrencyName: String = String()
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _nominal = source._nominal
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _isoCurrencyName = source._isoCurrencyName
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._isoCurrencyName) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 18)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 19)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 20)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 21)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 22)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 23)
      }
      if !_storage._isoCurrencyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isoCurrencyName, fieldNumber: 24)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Currency, rhs: Currency) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._isoCurrencyName != rhs_storage._isoCurrencyName {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Etf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Etf"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "fixed_commission"),
    18: .standard(proto: "focus_type"),
    19: .standard(proto: "released_date"),
    20: .standard(proto: "num_shares"),
    21: .standard(proto: "country_of_risk"),
    22: .standard(proto: "country_of_risk_name"),
    23: .same(proto: "sector"),
    24: .standard(proto: "rebalancing_freq"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "min_price_increment"),
    30: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _fixedCommission: Quotation? = nil
    var _focusType: String = String()
    var _releasedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _numShares: Quotation? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _rebalancingFreq: String = String()
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _fixedCommission = source._fixedCommission
      _focusType = source._focusType
      _releasedDate = source._releasedDate
      _numShares = source._numShares
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _rebalancingFreq = source._rebalancingFreq
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._fixedCommission) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._focusType) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._releasedDate) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._numShares) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._rebalancingFreq) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._fixedCommission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._focusType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._focusType, fieldNumber: 18)
      }
      try { if let v = _storage._releasedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._numShares {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 21)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 22)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 23)
      }
      if !_storage._rebalancingFreq.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rebalancingFreq, fieldNumber: 24)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Etf, rhs: Etf) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._fixedCommission != rhs_storage._fixedCommission {return false}
        if _storage._focusType != rhs_storage._focusType {return false}
        if _storage._releasedDate != rhs_storage._releasedDate {return false}
        if _storage._numShares != rhs_storage._numShares {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._rebalancingFreq != rhs_storage._rebalancingFreq {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Future: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Future"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "lot"),
    5: .same(proto: "currency"),
    6: .same(proto: "klong"),
    7: .same(proto: "kshort"),
    8: .same(proto: "dlong"),
    9: .same(proto: "dshort"),
    10: .standard(proto: "dlong_min"),
    11: .standard(proto: "dshort_min"),
    12: .standard(proto: "short_enabled_flag"),
    13: .same(proto: "name"),
    14: .same(proto: "exchange"),
    15: .standard(proto: "first_trade_date"),
    16: .standard(proto: "last_trade_date"),
    17: .standard(proto: "futures_type"),
    18: .standard(proto: "asset_type"),
    19: .standard(proto: "basic_asset"),
    20: .standard(proto: "basic_asset_size"),
    21: .standard(proto: "country_of_risk"),
    22: .standard(proto: "country_of_risk_name"),
    23: .same(proto: "sector"),
    24: .standard(proto: "expiration_date"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "min_price_increment"),
    30: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _firstTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastTradeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _futuresType: String = String()
    var _assetType: String = String()
    var _basicAsset: String = String()
    var _basicAssetSize: Quotation? = nil
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _firstTradeDate = source._firstTradeDate
      _lastTradeDate = source._lastTradeDate
      _futuresType = source._futuresType
      _assetType = source._assetType
      _basicAsset = source._basicAsset
      _basicAssetSize = source._basicAssetSize
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _expirationDate = source._expirationDate
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._firstTradeDate) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._lastTradeDate) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._futuresType) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._assetType) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._basicAsset) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._basicAssetSize) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._expirationDate) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 4)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 5)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 12)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 13)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 14)
      }
      try { if let v = _storage._firstTradeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._lastTradeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._futuresType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._futuresType, fieldNumber: 17)
      }
      if !_storage._assetType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetType, fieldNumber: 18)
      }
      if !_storage._basicAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._basicAsset, fieldNumber: 19)
      }
      try { if let v = _storage._basicAssetSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 21)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 22)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 23)
      }
      try { if let v = _storage._expirationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Future, rhs: Future) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._firstTradeDate != rhs_storage._firstTradeDate {return false}
        if _storage._lastTradeDate != rhs_storage._lastTradeDate {return false}
        if _storage._futuresType != rhs_storage._futuresType {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._basicAsset != rhs_storage._basicAsset {return false}
        if _storage._basicAssetSize != rhs_storage._basicAssetSize {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._expirationDate != rhs_storage._expirationDate {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Share: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Share"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    15: .same(proto: "name"),
    16: .same(proto: "exchange"),
    17: .standard(proto: "ipo_date"),
    18: .standard(proto: "issue_size"),
    19: .standard(proto: "country_of_risk"),
    20: .standard(proto: "country_of_risk_name"),
    21: .same(proto: "sector"),
    22: .standard(proto: "issue_size_plan"),
    23: .same(proto: "nominal"),
    25: .standard(proto: "trading_status"),
    26: .standard(proto: "otc_flag"),
    27: .standard(proto: "buy_available_flag"),
    28: .standard(proto: "sell_available_flag"),
    29: .standard(proto: "div_yield_flag"),
    30: .standard(proto: "share_type"),
    31: .standard(proto: "min_price_increment"),
    32: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _ipoDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issueSize: Int64 = 0
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _sector: String = String()
    var _issueSizePlan: Int64 = 0
    var _nominal: MoneyValue? = nil
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _divYieldFlag: Bool = false
    var _shareType: ShareType = .unspecified
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _ipoDate = source._ipoDate
      _issueSize = source._issueSize
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _sector = source._sector
      _issueSizePlan = source._issueSizePlan
      _nominal = source._nominal
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _divYieldFlag = source._divYieldFlag
      _shareType = source._shareType
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._ipoDate) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSize) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._sector) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._issueSizePlan) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._nominal) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._divYieldFlag) }()
        case 30: try { try decoder.decodeSingularEnumField(value: &_storage._shareType) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 15)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 16)
      }
      try { if let v = _storage._ipoDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._issueSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSize, fieldNumber: 18)
      }
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 19)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 20)
      }
      if !_storage._sector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sector, fieldNumber: 21)
      }
      if _storage._issueSizePlan != 0 {
        try visitor.visitSingularInt64Field(value: _storage._issueSizePlan, fieldNumber: 22)
      }
      try { if let v = _storage._nominal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 25)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 26)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 27)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 28)
      }
      if _storage._divYieldFlag != false {
        try visitor.visitSingularBoolField(value: _storage._divYieldFlag, fieldNumber: 29)
      }
      if _storage._shareType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._shareType, fieldNumber: 30)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Share, rhs: Share) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._ipoDate != rhs_storage._ipoDate {return false}
        if _storage._issueSize != rhs_storage._issueSize {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._sector != rhs_storage._sector {return false}
        if _storage._issueSizePlan != rhs_storage._issueSizePlan {return false}
        if _storage._nominal != rhs_storage._nominal {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._divYieldFlag != rhs_storage._divYieldFlag {return false}
        if _storage._shareType != rhs_storage._shareType {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAccruedInterestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccruedInterestsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAccruedInterestsRequest, rhs: GetAccruedInterestsRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetAccruedInterestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccruedInterestsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accrued_interests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accruedInterests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accruedInterests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accruedInterests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetAccruedInterestsResponse, rhs: GetAccruedInterestsResponse) -> Bool {
    if lhs.accruedInterests != rhs.accruedInterests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccruedInterest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccruedInterest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "value"),
    3: .standard(proto: "value_percent"),
    4: .same(proto: "nominal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._valuePercent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nominal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._valuePercent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nominal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AccruedInterest, rhs: AccruedInterest) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._value != rhs._value {return false}
    if lhs._valuePercent != rhs._valuePercent {return false}
    if lhs._nominal != rhs._nominal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetFuturesMarginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFuturesMarginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetFuturesMarginRequest, rhs: GetFuturesMarginRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetFuturesMarginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFuturesMarginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_margin_on_buy"),
    2: .standard(proto: "initial_margin_on_sell"),
    3: .standard(proto: "min_price_increment"),
    4: .standard(proto: "min_price_increment_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initialMarginOnBuy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._initialMarginOnSell) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minPriceIncrement) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minPriceIncrementAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initialMarginOnBuy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._initialMarginOnSell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minPriceIncrement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minPriceIncrementAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetFuturesMarginResponse, rhs: GetFuturesMarginResponse) -> Bool {
    if lhs._initialMarginOnBuy != rhs._initialMarginOnBuy {return false}
    if lhs._initialMarginOnSell != rhs._initialMarginOnSell {return false}
    if lhs._minPriceIncrement != rhs._minPriceIncrement {return false}
    if lhs._minPriceIncrementAmount != rhs._minPriceIncrementAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instrument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentResponse, rhs: InstrumentResponse) -> Bool {
    if lhs._instrument != rhs._instrument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Instrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "class_code"),
    4: .same(proto: "isin"),
    5: .same(proto: "lot"),
    6: .same(proto: "currency"),
    7: .same(proto: "klong"),
    8: .same(proto: "kshort"),
    9: .same(proto: "dlong"),
    10: .same(proto: "dshort"),
    11: .standard(proto: "dlong_min"),
    12: .standard(proto: "dshort_min"),
    13: .standard(proto: "short_enabled_flag"),
    14: .same(proto: "name"),
    15: .same(proto: "exchange"),
    16: .standard(proto: "country_of_risk"),
    17: .standard(proto: "country_of_risk_name"),
    18: .standard(proto: "instrument_type"),
    19: .standard(proto: "trading_status"),
    20: .standard(proto: "otc_flag"),
    21: .standard(proto: "buy_available_flag"),
    22: .standard(proto: "sell_available_flag"),
    23: .standard(proto: "min_price_increment"),
    24: .standard(proto: "api_trade_available_flag"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _ticker: String = String()
    var _classCode: String = String()
    var _isin: String = String()
    var _lot: Int32 = 0
    var _currency: String = String()
    var _klong: Quotation? = nil
    var _kshort: Quotation? = nil
    var _dlong: Quotation? = nil
    var _dshort: Quotation? = nil
    var _dlongMin: Quotation? = nil
    var _dshortMin: Quotation? = nil
    var _shortEnabledFlag: Bool = false
    var _name: String = String()
    var _exchange: String = String()
    var _countryOfRisk: String = String()
    var _countryOfRiskName: String = String()
    var _instrumentType: String = String()
    var _tradingStatus: SecurityTradingStatus = .unspecified
    var _otcFlag: Bool = false
    var _buyAvailableFlag: Bool = false
    var _sellAvailableFlag: Bool = false
    var _minPriceIncrement: Quotation? = nil
    var _apiTradeAvailableFlag: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _ticker = source._ticker
      _classCode = source._classCode
      _isin = source._isin
      _lot = source._lot
      _currency = source._currency
      _klong = source._klong
      _kshort = source._kshort
      _dlong = source._dlong
      _dshort = source._dshort
      _dlongMin = source._dlongMin
      _dshortMin = source._dshortMin
      _shortEnabledFlag = source._shortEnabledFlag
      _name = source._name
      _exchange = source._exchange
      _countryOfRisk = source._countryOfRisk
      _countryOfRiskName = source._countryOfRiskName
      _instrumentType = source._instrumentType
      _tradingStatus = source._tradingStatus
      _otcFlag = source._otcFlag
      _buyAvailableFlag = source._buyAvailableFlag
      _sellAvailableFlag = source._sellAvailableFlag
      _minPriceIncrement = source._minPriceIncrement
      _apiTradeAvailableFlag = source._apiTradeAvailableFlag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._classCode) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._isin) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lot) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._klong) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kshort) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dlong) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dshort) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._dlongMin) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dshortMin) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._shortEnabledFlag) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRisk) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._countryOfRiskName) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._instrumentType) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._tradingStatus) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._otcFlag) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._buyAvailableFlag) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._sellAvailableFlag) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._minPriceIncrement) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._apiTradeAvailableFlag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 2)
      }
      if !_storage._classCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classCode, fieldNumber: 3)
      }
      if !_storage._isin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isin, fieldNumber: 4)
      }
      if _storage._lot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lot, fieldNumber: 5)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 6)
      }
      try { if let v = _storage._klong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._dlong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dshort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dlongMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dshortMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._shortEnabledFlag != false {
        try visitor.visitSingularBoolField(value: _storage._shortEnabledFlag, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 14)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 15)
      }
      if !_storage._countryOfRisk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRisk, fieldNumber: 16)
      }
      if !_storage._countryOfRiskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryOfRiskName, fieldNumber: 17)
      }
      if !_storage._instrumentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentType, fieldNumber: 18)
      }
      if _storage._tradingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tradingStatus, fieldNumber: 19)
      }
      if _storage._otcFlag != false {
        try visitor.visitSingularBoolField(value: _storage._otcFlag, fieldNumber: 20)
      }
      if _storage._buyAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._buyAvailableFlag, fieldNumber: 21)
      }
      if _storage._sellAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._sellAvailableFlag, fieldNumber: 22)
      }
      try { if let v = _storage._minPriceIncrement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if _storage._apiTradeAvailableFlag != false {
        try visitor.visitSingularBoolField(value: _storage._apiTradeAvailableFlag, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Instrument, rhs: Instrument) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._classCode != rhs_storage._classCode {return false}
        if _storage._isin != rhs_storage._isin {return false}
        if _storage._lot != rhs_storage._lot {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._klong != rhs_storage._klong {return false}
        if _storage._kshort != rhs_storage._kshort {return false}
        if _storage._dlong != rhs_storage._dlong {return false}
        if _storage._dshort != rhs_storage._dshort {return false}
        if _storage._dlongMin != rhs_storage._dlongMin {return false}
        if _storage._dshortMin != rhs_storage._dshortMin {return false}
        if _storage._shortEnabledFlag != rhs_storage._shortEnabledFlag {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._countryOfRisk != rhs_storage._countryOfRisk {return false}
        if _storage._countryOfRiskName != rhs_storage._countryOfRiskName {return false}
        if _storage._instrumentType != rhs_storage._instrumentType {return false}
        if _storage._tradingStatus != rhs_storage._tradingStatus {return false}
        if _storage._otcFlag != rhs_storage._otcFlag {return false}
        if _storage._buyAvailableFlag != rhs_storage._buyAvailableFlag {return false}
        if _storage._sellAvailableFlag != rhs_storage._sellAvailableFlag {return false}
        if _storage._minPriceIncrement != rhs_storage._minPriceIncrement {return false}
        if _storage._apiTradeAvailableFlag != rhs_storage._apiTradeAvailableFlag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsRequest, rhs: GetDividendsRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDividendsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDividendsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dividends"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dividends) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dividends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dividends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetDividendsResponse, rhs: GetDividendsResponse) -> Bool {
    if lhs.dividends != rhs.dividends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dividend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dividend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dividend_net"),
    2: .standard(proto: "payment_date"),
    3: .standard(proto: "declared_date"),
    4: .standard(proto: "last_buy_date"),
    5: .standard(proto: "dividend_type"),
    6: .standard(proto: "record_date"),
    7: .same(proto: "regularity"),
    8: .standard(proto: "close_price"),
    9: .standard(proto: "yield_value"),
    10: .standard(proto: "created_at"),
  ]

  fileprivate class _StorageClass {
    var _dividendNet: MoneyValue? = nil
    var _paymentDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _declaredDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastBuyDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dividendType: String = String()
    var _recordDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _regularity: String = String()
    var _closePrice: MoneyValue? = nil
    var _yieldValue: Quotation? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dividendNet = source._dividendNet
      _paymentDate = source._paymentDate
      _declaredDate = source._declaredDate
      _lastBuyDate = source._lastBuyDate
      _dividendType = source._dividendType
      _recordDate = source._recordDate
      _regularity = source._regularity
      _closePrice = source._closePrice
      _yieldValue = source._yieldValue
      _createdAt = source._createdAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dividendNet) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paymentDate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._declaredDate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastBuyDate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._dividendType) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._recordDate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._regularity) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._closePrice) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._yieldValue) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dividendNet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paymentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._declaredDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastBuyDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._dividendType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dividendType, fieldNumber: 5)
      }
      try { if let v = _storage._recordDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._regularity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._regularity, fieldNumber: 7)
      }
      try { if let v = _storage._closePrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._yieldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dividend, rhs: Dividend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dividendNet != rhs_storage._dividendNet {return false}
        if _storage._paymentDate != rhs_storage._paymentDate {return false}
        if _storage._declaredDate != rhs_storage._declaredDate {return false}
        if _storage._lastBuyDate != rhs_storage._lastBuyDate {return false}
        if _storage._dividendType != rhs_storage._dividendType {return false}
        if _storage._recordDate != rhs_storage._recordDate {return false}
        if _storage._regularity != rhs_storage._regularity {return false}
        if _storage._closePrice != rhs_storage._closePrice {return false}
        if _storage._yieldValue != rhs_storage._yieldValue {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
